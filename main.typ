#import "src/layout/standard.typ": setup_layout
#import "src/course_work/template.typ": project
#import "@preview/indenta:0.0.3": fix-indent
#show: setup_layout
#show: project.with(
  student_name: "ЖАДАН Олег",
  student_name_genitive: "Жадану Олегу Анатолійовичу",
  group: "ІПЗ-21-9-д",
  course_num: "IV",
  city: "Кам’янське",
  department_name: "Технолого-економічне",
  commission_name: "Програмного забезпечення та прикладної математики",
  commission_name_short: "ІПЗ та ПМ",
  knowledge_branch: "12 Інформаційні технології",
  specialty: "121 “Інженерія програмного забезпечення”",
  discipline: "Конструювання програмного забезпечення",
  title: "Практичне застосування патерну проектування Strategy у мові програмування Python",
  work_due_to: "02.12.2024",
  task_received_at: "24.02.2024",
  supervisor_name: "КРАВЕЦЬ Михайло",
  supervisor_title: "Викладач",
  commission_head_name: "КРАВЕЦЬ Михайло",
  commission_members: (
    "БАЖАН Станіслав", 
    "РОЖЕНЮК Олександр",
    "КРАВЕЦЬ Михайло"
  ),
  calendar_plan_data: (
    ("Аналіз проблемної галузі та постановка задачі", "01.10.2024 - 10.10.2024"),
    ("Опис прийнятих проектних рішень", "10.10.2024 - 15.10.2024"),
    ("Розробка програми", "15.10.2024 - 25.10.2024"),
    ("Опис розробленої програми", "25.10.2024 - 05.11.2024"),
    ("Графічна частина (презентація), вступ, висновки, перелік посилань, реферат", "05.11.2024 - 11.11.2024"),
    ("Попередній захист роботи", "25.11.2024"),
    ("Захист роботи", "02.12.2024"),
  ),
  initial_data: [
   Дослідити обрану предметну галузь та спроектувати концептуальну, логічну та фізичну моделі даних, відповідно до вимог цієї галузі. На основі розроблених моделей створити програмний додаток на Python, який демонструватиме роботу патерну проектування Strategy. Програма має містити кілька альтернативних стратегій для виконання певних дій у рамках предметної області, дозволяючи обирати стратегію під час виконання програми.
  ], 
  abstract: [
    #align(center)[*Пояснювальна записка до курсової роботи*]
    
    *Об'єкт розробки* — патерн проектування Strategy.

    *Мета розробки* — дослідити доцільність використання патерну у
    програмах написаних на Python.

    *Метод проектування* — мова програмування Python, система збірки 
Poetry, інтерпретатор Python 3.12.1, Mermaid.js, OS Windows 10 Pro, VS Code 

    Паттерн стратегій - це патерн поведінкового дизайну, який дозволяє 
об'єкту обирати поведінку або алгоритм під час виконання. Цей патерн 
визначає сімейство алгоритмів, інкапсулює кожен з них і робить їх 
взаємозамінними, гарантуючи, що алгоритми можуть змінюватися 
незалежно від клієнтів, які їх використовують.

Патерн «Стратегія» підтримує принцип «відкритий/закритий», коли код 
є відкритим для розширення, але закритим для модифікації, що 
забезпечує гнучкість і масштабованість програмних систем.

  *Ключові компоненти стратегічного патерну:*
- _Контекст:_ Зберігає посилання на об'єкт стратегії та дозволяє 
взаємодіяти з ним.
- _Інтерфейс стратегії:_ Загальний інтерфейс, що реалізується всіма 
конкретними стратегіями.
- _Конкретні стратегії:_ Реалізації алгоритму, визначеного в 
інтерфейсі стратегій.

*Реалізація на Python*

Динамічна природа Python спрощує патерн стратегій. Ми 
використовуємо функції або класи для визначення стратегій та їх 
призначення під час виконання.
    #align(bottom)[
      ПРОГРАМА, ПАТЕРНИ ПРОЕКТУВАННЯ, UML, ДІАГРАМА КЛАСІВ
    ]
  ]
)
#show: fix-indent(unsafe: true)
#heading(level: 1, numbering: none, "ВСТУП")

Сучасне програмування вимагає гнучких, масштабованих і легких у підтримці рішень, що особливо актуально у випадках розробки великих програмних продуктів та архітектур. У зв’язку з постійним ростом складності завдань, які вирішують програмні системи, надзвичайно важливим стає вміння правильно організувати код, використовуючи надійні підходи до структуризації. Одним із ключових напрямів в архітектурі програмних додатків є використання патернів проектування (англ. *design patterns*). Патерни проектування дозволяють стандартизувати архітектурні рішення, що робить код більш зрозумілим для розробників, скорочує час на впровадження змін та підвищує загальну надійність програмного продукту.

Патерн проектування "Стратегія" (англ. *Strategy pattern*) є одним із таких патернів, що належать до класу поведінкових. Він спрямований на динамічне визначення поведінки об'єкта шляхом заміни однієї реалізації на іншу під час виконання програми. Основна ідея патерну полягає в тому, щоб створити абстракцію для різних алгоритмів і дозволити клієнту вибирати та змінювати алгоритм на льоту, без потреби вносити зміни до коду самого клієнта. Це дозволяє знизити зв’язність компонентів системи, що в свою чергу полегшує підтримку та розширення функціоналу. Важливість цього патерну проявляється у випадках, коли одна задача може мати кілька варіантів розв’язання, і необхідно вибрати найбільш оптимальний або гнучкий варіант залежно від умов використання програми.

У цій курсовій роботі буде детально розглянуто патерн проектування "Стратегія" та його застосування в програмуванні. Зокрема, буде проаналізовано, як його можна інтегрувати для реалізації вибору алгоритму на основі поточних потреб користувача або зовнішніх обставин. Також буде показано, яким чином цей патерн дозволяє зробити код більш модульним, легким для читання та супроводження, а також як він сприяє дотриманню принципів об’єктно-орієнтованого програмування, таких як *SOLID*-принципи. Розгляд цього патерну дозволить зрозуміти його місце у розробці програмних продуктів, а також його переваги та недоліки, особливо у порівнянні з іншими підходами до організації коду.

Метою курсової роботи є вивчення основних принципів патерну "Стратегія", його структури, особливостей реалізації та прикладних варіантів використання. У процесі дослідження буде створено програмний додаток, що продемонструє роботу патерну "Стратегія" у реальних умовах.
#pagebreak()
#heading(level: 1, "Аналіз проблемної галузі та постановка задачі")
#align(center, heading(level: 2, "Основні поняття"))

*Об'єктно-орієнтоване програмування (ООП)* — це парадигма програмування, яка використовує "об'єкти" — дані, організовані в класи, що містять поля та методи, для проектування програм та застосунків. Основна мета ООП полягає в створенні програм, де дані та операції над ними є організованими в єдиний блок, що дозволяє зручніше управляти та розширювати програмний код. ООП допомагає моделювати реальні об'єкти та їх взаємодію, що дозволяє зменшити складність розробки та підтримки програмного забезпечення.

Важливими *принципами ООП є*: наслідування, поліморфізм, інкапсуляція та абстракція. ООП дає можливість створювати багатократні шаблони для використання класів, що дозволяє зменшити дублювання коду. В Python ці принципи реалізуються за допомогою класів, наслідування, і поліморфізму, що забезпечує масштабованість і гнучкість.

Python підтримує об'єктно-орієнтований підхід, де основними будуть класи і об'єкти. Однак важливою особливістю є те, що Python підтримує динамічну типізацію та інтерпретацію, що надає більшу гнучкість у порівнянні з більш строгими мовами, такими як C++, C\#, Java та інші. 

Абстракція дозволяє приховати складні деталі реалізації, залишаючи тільки основні, важливі для користувача частини системи. Наприклад, абстрактні класи не можуть бути інстанційовані, але надають шаблон для наслідування конкретними класами. У Python це досягається через використання абстрактних базових класів (ABC) з модулем abc, де абстрактні методи визначаються як методи без реалізації, що мають бути перевизначені в дочірніх класах.

#parbreak()

*pip* — це пакетний менеджер для Python, який використовується для інсталяції та керування бібліотеками та залежностями програм. Пакети в Python — це набори модулів або скриптів, які реалізують певний функціонал, що можна використовувати в різних програмах. Використання pip дозволяє зручно інсталювати, оновлювати або видаляти пакети з Python Package Index (PyPI), що є центральним репозиторієм для Python-бібліотек.

Це надзвичайно важливо, оскільки більшість програм сьогодні використовують зовнішні бібліотеки для вирішення різноманітних задач — від роботи з базами даних до обробки зображень чи навіть машинного навчання. За допомогою pip програмісти можуть швидко інтегрувати готові рішення та фокуватися на бізнес-логіці, знижуючи час, необхідний для розробки та тестування. Оскільки Python має величезну екосистему бібліотек, правильне керування залежностями через pip є критично важливим для підтримки стабільності та безпеки програмного забезпечення.

*PyCharm* — це популярне середовище розробки для Python, яке надає потужні інструменти для налагодження, тестування та аналізу коду. Воно підтримує автоматичне завершення коду, підсвічування синтаксису, інтеграцію з системами контролю версій, такими як Git, і має вбудовану підтримку для роботи з базами даних та віртуальними середовищами Python.

*VS Code* — це легке та потужне середовище розробки, яке підтримує Python завдяки встановленню відповідних розширень. VS Code є популярним вибором серед розробників завдяки своїй гнучкості, швидкості роботи та величезному набору плагінів, що дозволяють налаштувати середовище для різних типів проектів. За допомогою таких розширень, як Python Extension, VS Code надає вбудовану підтримку для відладки, автодоповнення та роботи з віртуальними середовищами Python.

*Патерн проектування* — це загальне повторюване рішення для часто зустрічаємої проблеми в архітектурі або дизайні програмного забезпечення. Використання патернів проектування дозволяє розробникам застосовувати ефективні, перевірені рішення для загальних задач, знижуючи складність і підвищуючи гнучкість систем.

*Патерн Strategy (Стратегія)* — це поведінковий патерн проектування, який дозволяє визначити сімейство алгоритмів, інкапсулювати кожен з них окремо та зробити їх взаємозамінними. У цьому патерні стратегія означає вибір конкретного алгоритму для виконання певного завдання, залежно від умов. В Python цей патерн часто реалізується за допомогою абстрактних класів або інтерфейсів, де різні реалізації алгоритмів можуть бути замінені без змін в основному класі. Це дозволяє змінювати поведінку об'єкта в залежності від конкретних вимог без зміни його внутрішньої структури.

#parbreak()
#align(center, heading(level: 2, "Історія виникнення та розвитку патерна Strategy"))

Патерн проектування Strategy належить до групи поведінкових патернів і був вперше описаний в книзі @Gamma1994DesignPatterns Книга стала основним джерелом для розвитку об'єктно-орієнтованого програмування та патернів проектування, що дозволило стандартизувати багато рішень, які повторюються в розробці програмного забезпечення.

Патерн Strategy виник в результаті необхідності надавати програмам гнучкість у виборі алгоритмів або варіантів обчислень, не змінюючи їх основну структуру. На момент написання книги "Design Patterns", багато програм розроблялися з використанням жорстко закодованих алгоритмів, що ускладнювало їх оновлення та підтримку. Стратегії дозволяють абстрагувати алгоритм від його реалізації, зробивши систему більш гнучкою та легко розширюваною.

Протягом наступних років патерн Strategy знайшов широке застосування в різних галузях програмування, зокрема в області геймдизайну, обробки даних і фінансових системах. Сьогодні його часто використовують для заміни статичних алгоритмів на динамічні, що дозволяє адаптувати програму до змінних умов.
#parbreak()
#align(center, heading(level: 2, "Формування проблеми та постановка задачі"))

*а) Аналіз джерел інформації*:\
Патерн проектування Strategy створений для забезпечення гнучкості та можливості легкої заміни алгоритмів виконання окремих операцій в програмі без необхідності змінювати інші частини коду. Використання цього патерну базується на принципах об’єктно-орієнтованого програмування, де велике значення надається композиції та делегуванню для відокремлення алгоритмів від їхнього контексту. Це дозволяє програмі динамічно змінювати поведінку об’єктів під час виконання. Вивчаючи джерела з об’єктно-орієнтованого програмування, такі як книги, технічні документи та статті, можна побачити, як патерн Strategy використовувався для розв’язання проблем із гнучкістю коду і забезпеченням принципу відкрито/закрито.

*б) Основні компоненти патерну:*\
 - Інтерфейс стратегії (Strategy Interface): Це абстрактний клас або інтерфейс, який оголошує методи, необхідні для реалізації алгоритму. Усі конкретні стратегії успадковують цей інтерфейс, що забезпечує можливість їх взаємозамінності.
 - Конкретні стратегії (Concrete Strategies): Ці класи реалізують методи, визначені інтерфейсом стратегії. Кожна конкретна стратегія представляє окремий варіант алгоритму, дозволяючи гнучко використовувати різні підходи для досягнення однакової мети.
 - Контекст (Context): Це клас, який містить посилання на об'єкт стратегії та відповідає за виклик методу стратегії. Контекст делегує обчислення об'єкту стратегії, не прив’язуючись до конкретної реалізації, що робить систему відкритою до змін.

*в) Проблеми, які вирішує патерн Strategy:*\
 - Заміна алгоритмів у рантаймі: Забезпечує можливість динамічної зміни алгоритму під час виконання програми без потреби перезаписувати вихідний код.
 - Усунення жорсткої прив’язки до конкретного алгоритму: Допомагає уникнути залежності від конкретного способу виконання операцій, дозволяючи гнучко змінювати алгоритми.
 - Зменшення умовних операторів: За рахунок чіткого розділення між контекстом і стратегією значно скорочується кількість умовних операторів у коді, що робить його простішим для підтримки та розширення.
 - Підтримка принципу відкрито/закрито: Strategy забезпечує, що нові алгоритми можна додавати без зміни існуючого коду, дотримуючись принципу відкрито/закрито з SOLID.
 - Спрощення одиничних компонентів: Стратегії працюють незалежно одна від одної, що дозволяє тестувати та підтримувати кожен алгоритм окремо.
 - Забезпечення гнучкості та розширюваності коду: Стратегії легко додаються і змінюються, що робить патерн зручним для побудови масштабованих систем.
 - Виконання альтернативних дій при однакових вхідних умовах: Патерн дозволяє використовувати різні стратегії для обробки однакових даних, що важливо в умовах, коли поведінка залежить від специфічного алгоритму.

*г) Постановка задачі:*\
- Розробити консольну програму з використанням патерну Strategy, яка буде десерілувати данні із файла/-лів з розширенням (json, csv, xml та інші) і виводити дані в консоль у вигляді таблиць для зручності.
Цей патерн підходить для розв’язання проблем, пов’язаних зі складними умовами та випадками, коли необхідно зберегти незалежність між алгоритмом і його використанням, залишаючи можливість для розширення системи без шкоди для її цілісності.

#parbreak()
#align(center, heading(level: 2, "Середовище розробки")) 
#parbreak()

*Python* — це потужна, високоабстрактна мова програмування, яка набрала популярності завдяки своїй простоті, зрозумілому синтаксису та широкій підтримці бібліотек. Python часто використовують для розробки веб-додатків, наукових розрахунків, автоматизації завдань, а також для роботи з даними.

*VS Code* — це популярне середовище розробки (IDE), яке підтримує Python завдяки спеціальному розширенню. Воно має зручний інтерфейс, інтегровану підтримку Git, налагоджувач, а також дозволяє працювати з різноманітними мовами програмування. Встановивши розширення для Python, VS Code пропонує автоматичне доповнення коду, виведення помилок і підтримку віртуальних середовищ.\
Python Package:
  - *rich* — потужна бібліотека для виведення кольорових та стилізованих текстів у термінал. Вона підтримує виведення таблиць, прогрес-барів, візуальних компонентів, що робить взаємодію з користувачем значно зручнішою та інтуїтивно зрозумілою.
#pagebreak()
#heading("Опис прийнятих проектних рішень")
#align(center, heading(level: 2, "Концептуальна модель проблемної галузі"))

Концептуальна модель проблемної галузі для патерну Strategy відображає абстрактну структуру та ключові взаємодії між елементами системи, яка забезпечує можливість змінювати алгоритми поведінки об’єктів у режимі реального часу. Головними компонентами цієї моделі є:

- *Контекст (Context)* – це основний елемент системи, що визначає середовище виконання алгоритмів. Контекст зберігає посилання на стратегію і передає їй виконання певної поведінки, залишаючись "посередником" між клієнтським кодом і алгоритмом. Хоча Контекст виконує зовнішню функцію інтерфейсу для клієнтів, він не реалізує самостійно поведінкові алгоритми, а делегує їхній запуск відповідному об’єкту стратегії.

- *Стратегія (Strategy)* – це інтерфейс або абстрактний клас, що визначає спільний вигляд алгоритмів або поведінкових моделей, які можна застосовувати в Контексті. Він описує методи, котрі мають реалізувати всі конкретні стратегії. Цей компонент забезпечує узагальнений шаблон, у межах якого можуть бути визначені конкретні алгоритми.

- *Конкретні стратегії (Concrete Strategies)* – це реалізації стратегії, кожна з яких надає специфічний алгоритм або форму поведінки, імплементуючи загальний інтерфейс стратегії. Кожна конкретна стратегія здатна виконувати необхідні дії власним чином, але з точки зору Контексту, всі вони є взаємозамінними. Це дозволяє легко підміняти один алгоритм іншим у межах однієї системи.

Концептуальна модель Strategy наочно демонструє, як вибір алгоритму відокремлюється від його виконання, що дозволяє гнучко змінювати поведінку об’єктів без необхідності зміни їхнього коду. Це забезпечує підвищену адаптивність системи, спрощує модифікацію та тестування, адже кожна стратегія може бути розроблена й протестована окремо, без взаємозалежності з іншими компонентами. 

Розглянемо приклад застосування патерну Strategy у данному проекті:
  - Контекст (Context) - клас вибирає за указаним файлом обирає стратегію (reader) для успішої і коректної десерилізації
  - Стратегія (*AbstractReader*) - це базовий інтерфейс який представляє методи для стратегій.
  - Конкретні стратегії - *`JSONReader`*, *`CSVReader`*, *`XMLReader`* і тд. Кожен з них імплементує *`AbstractReader`* для десерилізації данних.
#figure(image("photo/class_diagram_strategy.png", width: 100%), caption: [Концептуальна модель])
#parbreak()
#align(center, heading(level: 2, "Логічна модель проблемної галузі"))

Логічно програмний додаток складається із класів які кожен має свій окремий функціонал (дотримання одного із принципів SOLID - Принцип єдиної відповідальності (Single responsibility principle)).

Виконання програми починається в модулі main.py.

*`Context`* - це клас в якому пібирається сама стратегія виходячи із формату файла.
Клас має такі атрибути:
- `__init__(self)` - конструкція для створення об'єкта типу *`Context`* який приймає аргументи
- `get_reader()` - повертає читач яким було десерилізовано данні, він же стратегія.
- `get_model()` - повертає список данних типу DataModel
- `get_header()` -повертає позицію полів типу DataModel 
*`AbstractReader`* - це інтерфейс стратегій який представлений двума методами:
- `get_model()` - повертає список данних типу DataModel
- `get_header()` - повертає позицію полів типу DataModel
Три класи, вони ж конкретні стратегії: *`JSONReader`*, *`CSVReader`*, *`XMLReader`* які імплеменують інтрефейс і використовуються в *`Context`*

Додаткові класи:
*`Zomboid`* - ключевий клас проекту
  - `__init__(self)` - конструкція для створення об'єкта типу *`Zomboid`* який приймає аргументи
  - `print_models()` - функція яка виводить в консоль таблицю за отримавшими данними коструктора
*`Paginator`* - клас який преставляє собою фільтром данних
  - `__init__(self)` - конструкція для створення об'єкта типу *`Paginator`* який приймає аргументи які виступають фільтрами.
  - `get_models` - повертає список типу DataModel на який було застосовано фільтри
*`PrinterModel`* - клас який реалізує вивід у консоль або ж термінал
  - `__init__(self)` - контрукція для створення об'єкта типу *`PrinterModel`* який приймає аргументи
  - `print()` - функція яка виводить в консоль таблицю створену за допомогою данних і утиліти *rich*
*`DataModel`* - об'єктне представлення данних
  - `id, name, type_object, condion, amount` - поля класу
  - `default_dict_model` - словарь який представляє позиції полів за замовчуванням

#figure(
  caption: "Діаграма класів проекта"
)[
  #image("photo/class_diagram_1.png", width: 100%)
   #image("photo/class_diagram_2.png", width: 100%)
] <diagram_class_project>


#parbreak()
#align(center, heading(level: 2, "Фізична модель проблемної галузі"))

#heading(level: 3, "Ієрархія проекту")

#figure(caption: "Файлова ієрархія проекта")[
```
- .data/
- src/
  - context.py
  - model.py
  - paginator.py
  - printer_model.py
  - io/
    - csv_reader.py
    - file_reader.py
    - json_reader.py
    - xml_reader.py
- require/
  - requirements.txt
- test/
- main.py
```
] <project_hierarchy>
*`.data/`* - папка з данними юзера (вони ігноруються системою Git)\
*`src/`* - модуль із кодом (*Zomboid*)
*`context.py`* - (*Context*) клас в якому пібирається сама стратегія виходячи із формату файла\
*`model.py`* - (*DataModel*) об'єктне представлення данних\
*`paginator.py`* - (*Paginator*) клас який преставляє собою фільтром десерилізованих данних\
*`printer_model.py`* - (*PrinterModel*) клас який реалізує вивід у консоль або ж термінал\
*`io/`* - модуль який представляє собою набір класів для роботи із файлами\
*`csv_reader.py`* - (*CSVReader*) клас для роботи із файлами типу .csv, він же стратегія\
*`file_reader.py`* - (*AbstractReader*) інтерфейс стратегій\
*`json_reader.py`* - (*JSONReader*) клас для роботи із файлами типу .json, він же стратегія\
*`xml_reader.py`* - (*XMLReader*) клас для роботи із файлами типу .xml, він же стратегія\
*`require/`* - папка із залежностями\
*`requirements.txt`* - список залежностей проекта\
*`test/`* - папка із тестами до проекта\
*`main.py`* - файл виконання програми

#heading(level: 3, "Компіляція та збірка")
Для запуску програми на Python не потрібно компілювати код, оскільки Python є інтерпретованою мовою. Ви можете безпосередньо запустити Python-скрипт.
Команда для запуску програми в ОС Linux (або Windows/macOS):
```bash
python3 main.py
```
Ця команда запустить файл main.py.

#heading(level: 3, "Залежності та платформи")
Цей проект використовує стандартні бібліотеки Python, а також бібліотеку rich для форматованого виведення в консолі. Програма сумісна з будь-якою платформою, де є інтерпретатор Python (Linux, Windows, macOS) і встановлена бібліотека rich.\
Необхідні версії:\
  - Python 3.6 і вище.
  - Бібліотека rich.
Для встановлення залежностей виконайте команду:\

```bash
pip install -r require/requirements.txt
```
А при оновленні залежностей (навіть якщо ви щось змінювали) виконайте команду:
```bash
pip freeze > require/requirements.txt
```
Після цього перевірте коректність залежностей @project_hierarchy[require]
#heading(level: 3, "Результат роботи програми")

1. Назначення файла який буде десерилізовано
2. Клас Context підбирає reader для цього формату файла який було вказано
3. Передає віддесерилізовані дані в клас Zomboid який виведе на екран таблицю об’єктів
#figure(image("photo/data_models.png", width: 80%))

#pagebreak()
#heading(numbering: none, "ВИСНОВОК")
У цій курсовій роботі було детально розглянуто та проаналізовано патерн проектування "Стратегія", який є одним із ключових методів у сучасній розробці програмного забезпечення. Застосування цього патерну допомагає розробникам створювати більш гнучкі та адаптивні програми, що легко розширюються та модифікуються.

Основна перевага патерну Strategy полягає у можливості динамічно змінювати поведінку об'єктів у час виконання програми. Це досягається завдяки принципу композиції, що дозволяє обирати потрібну поведінку на основі поточних умов або вимог, не змінюючи код об’єктів, що її використовують. Такий підхід дає змогу значно зменшити залежності між компонентами програми, зберігаючи їхню автономність. Замість традиційного наслідування патерн Strategy передбачає інтеграцію конкретних стратегій через інтерфейси, що дозволяє обирати різні алгоритми або логіку залежно від умов або вимог проекту.

Робота з патерном Strategy також сприяє підвищенню модульності програмного забезпечення. Це дає змогу легше тестувати та оновлювати окремі компоненти системи без ризику порушити її загальну функціональність. Завдяки чіткій структурі та використанню композиції програма стає більш гнучкою і зручною для підтримки. Крім того, Strategy дозволяє спрощувати процес розширення функціональності шляхом додавання нових стратегій без змін в існуючій архітектурі програми.

У підсумку, результати цієї роботи показали, що патерн проектування Strategy є важливим і корисним інструментом для розробки масштабованих, гнучких та легких у підтримці програмних систем. Застосування Strategy забезпечує створення коду, який добре організований, чистий та готовий до подальших змін. Це відкриває широкі можливості для інновацій та оптимізації, що особливо цінно в умовах швидких змін вимог та контекстів. Патерн "Стратегія" є незамінним інструментом при реалізації складних проектів, оскільки дозволяє командам розробників більш ефективно відповідати на нові виклики та вимоги, що виникають в процесі розробки та розвитку програмного забезпечення.

#heading(level: 1, "Перелік посилань")
- #bibliography(
  "ref/books.bib", title: none
)
- Refactoring guru: #link("https://refactoring.guru/design-patterns/strategy")
- Source code GitHub: #link("https://github.com/JordanOleg/course_work")
- rich: #link("https://github.com/Textualize/rich/tree/master")
